#    Kudu --- A fully functioning Gnu Emacs system
#    Copyright (C) 2023  Joar von Arndt
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.

#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.

#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <https://www.gnu.org/licenses/>.

#+title: Kudu
#+author: Joar von Arndt
#+STARTUP: overview
* What is Kudu?
[[https://github.com/JanJoar/Kudu-Emacs/blob/main/Logos/KuduLogo_red.svg]]

The complexity and extensibility of GNU Emacs, paired with its lack of integration with contemporary technical standards, has driven the development of Emacs distributions that contain packages and functionality not included by the GNU project. Kudu is a project meant to expand the scope of such distributions to every user-facing part of the operating system using dialects of the lisp programming language. This allows the user to easily and seamlessly "live in Emacs", using tools integrated directly into the program, such as the Emacs X Window Manager (EXWM), guix.el, and the Emacs Application Framework (EAF). Earlier distributions have focused on integrating Emacs within an otherwise alien system, like DOOM's and Spacemacs' focus on keybinds derived from the Vi editor, to maximize the number of workflows that the distribution could be incorporated into. Kudu does not take this approach, but rather empowers the user to construct their own system within a completely configurable system. All tools are written in lisp, the simple syntax of which allows for a seamless experience and self-sufficient system capable of performing all the daily tasks of modern life. It is hoped that this declarative and atomic system offered by GNU Guix will allow more secure and maintainable infrastructure.


The origin for the name is the kudu, an antelope similar to that of the Gnu, the namesake of the GNU Project. Kudu is not part of the GNU Project, and it's developers are not members of GNU or the FSF. However we share a positive opinion of free software and therefore want to contribute to its mainstream adoption. 
* Configuration

** Use-package
Probably one of the most useful packages, even if not very prominent when using emacs, is use-package. It allows you to declaratively write your configuration and have the included emacs package manager download them for you, and also have configurations for packages only run when packages are loaded, similarly to ~(with-eval-after-load ...)~. The variables set here simply enable this behaviour. The ~diminish~ package hides certain minor modes from being shown in the mode-line and is not installed by default. For this reason its used to check if Kudu has been run before, and therefore if it needs to update its package repos. Feel free to perform this check on any other package, or remove it entirely, but beware that ~(package-refresh-contents)~ must be run before the other ~use-package~ declarations for ~package.el~ to install all the other packages needed.

#+BEGIN_SRC elisp
  (setq use-package-always-defer t
        use-package-always-ensure t)

  (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
#+END_SRC

** Auto-compile
Compiles elisp files to improve the speed and responsiveness of Emacs at the cost of first-time startup time. The settings in ~init.el~ makes sure that updated elisp files take priority over older, compiled files.
#+BEGIN_SRC elisp
(use-package auto-compile 
  :ensure t
  :init
  (auto-compile-on-load-mode 1)
  (auto-compile-on-save-mode 1))
#+END_SRC

** EXWM
The Emacs X Window Manager allows you to use your entire desktop within emacs. Other windows are managed like traditional emacs buffers, and different workspaces are implemented using separate emacs frames. This is arguably the largest change to using traditional window managers and desktop environments, and it transforms emacs from simply a program that can do everything to /the/ way to interact with one's computer.

However, Emacs can still be used without constituting the entire system. Therefore EXWM should only be loaded if no other window manager is running. That way startup time isn't wasted whenever the user wants to run Emacs in the terminal, on a computer using a desktop environment, or another window manager.

#+BEGIN_SRC elisp
  (use-package exwm
    :init
    (setq switch-to-buffer-obey-display-actions t)
    (shell-command "wmctrl -m ; echo $status" "*window-manager*" "*window-manager-error*")

    (when (and
           (get-buffer "*window-manager-error*") ;; The shell command has to both encounter an error and a running in an X environment.
           (eq window-system 'x))

      (display-battery-mode 1)
      (setq display-time-day-and-date t)
      (display-time-mode 1)

      ;; Changes the name of EXWM-buffers to the corresponding window-name rather than *EXWM*<N>.
      (add-hook 'exwm-update-class-hook
                (lambda ()
                  (exwm-workspace-rename-buffer exwm-class-name)))

      ;; Creates 3 different workspaces, from 0 to 2.
      (setq exwm-workspace-number 3)

      ;; These  keys will always be sent to EXWM rather than to the X window.
      (setq exwm-input-prefix-keys
            '(?\C-x
              ?\C-g
              ?\M-x
              ?\M-z))

      ;; Sends the key after C-q directly to the X window.
      ;; (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

      (setq exwm-input-global-keys
            `(
              ([?\s-r] . exwm-reset)
              ([s-left] . windmove-left)
              ([s-right] . windmove-right)
              ([s-up] . windmove-up)
              ([s-down] . windmove-down)
              ([?\s-w] . exwm-workspace-switch)
              ([?\C-q] . exwm-input-send-next-key)
              ([?\s-a] . (lambda (command)
                           (interactive (list (read-shell-command "$ ")))
                           (start-process-shell-command command nil command)))
              ([?\s-w] . exwm-workspace-switch)
              ([?\s-u] . (lambda ()
                            (interactive)
                            (shell-command "brightnessctl --quiet --min-value set +10")))
              ([?\s-d] . (lambda ()
                           (interactive)
                           (shell-command "brightnessctl --quiet --min-value set 10-")))
              ))
      ;; Actually starts EXWM
      (exwm-enable)
      )

    (when (get-buffer "*window-manager*")
      (kill-buffer "*window-manager*"))
    (when (get-buffer "*window-manager-error*")
      (kill-buffer "*window-manager-error*")))
#+END_SRC

** General visual elements
Visible bell changes the otherwise quite jarring bell sound into a visual flash on it top and bottom of the emacs frame. ~prettify-symbols-mode~ allows certain major modes to change the appearance of strings, the classic example being the Greek letter lambda in lisp-modes for lambda calculus. ~pixel-scroll-precision-mode~ allows you to scroll past things like images without buffers jumping around all the time.
 
#+BEGIN_SRC elisp
  (setq visible-bell t
        global-prettify-symbols-mode 1
        pixel-scroll-precision-mode t)
    (global-display-line-numbers-mode)
#+END_SRC

The beacon package shows off the location the point whenever you move to a window or scroll a buffer so that you don't lose it.
#+BEGIN_SRC elisp
    (use-package beacon
    :diminish beacon-mode
    :init
    (beacon-mode 1))
#+END_SRC

Solaire-mode makes it easy to distinguish between warnings, popups and messages by tinting the background of those buffers slightly darker, as long as the current theme supports it.

#+BEGIN_SRC elisp
        (use-package solaire-mode
          :init
          (solaire-global-mode))
        (setq pixel-scroll-precision-mode t)
#+END_SRC

Formats tabs to Linux-kernel standards and keeps them so using the ~aggressive-indent~ package.

#+BEGIN_SRC elisp
  (setq-default tab-width 8)
  (setq-default standard-indent 8)
  (setq-default indent-tabs-mode nil)

  (use-package aggressive-indent
    :diminish aggressive-indent-mode
    :hook (prog-mode . aggressive-indent-mode))
#+END_SRC

Enable mouse use when running Emacs in a terminal emulator.

#+BEGIN_SRC elisp
  (xterm-mouse-mode)
#+END_SRC

Without this setting emacs sometimes asks for confirmation via a "Yes or no" prompt, and sometimes "y or n". This is generally difficult to predict, and so this setting forces the message to always send "y or n" forms, like most programs run in a terminal.

#+BEGIN_SRC elisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

The default Emacs mode-line is a bit busy and certain elements of it are difficult to intuitively understand. This simplifies it considerably to make it more readable and also adds a header line.

#+BEGIN_SRC elisp
  (defun mode-line-padding ()
    (let ((r-length (length (format-mode-line mode-line-end-spaces))))
      (propertize " "
                  'display `(space :align-to (- right ,r-length)))))

  (setq-default mode-line-format
              '(
                "|"
                "%e"
                (:eval (unless (string-match-p "\\*.*\\*" (buffer-name))
                    (let* ((read-only (and buffer-read-only (buffer-file-name)))
                           (modified (buffer-modified-p)))
                      (propertize
                       (if read-only "  " (if modified " !" "  "))))))
                " "
                (:eval (propertize (format "%s" (buffer-name)) 'face 'bold))
                " "
                (:eval (mode-line-padding))
                (:eval (setq mode-line-end-spaces mode-line-misc-info))
                ))
  (setq-default header-line-format
                '(
                  "  "
                  (:eval (propertize (format "%s" mode-name) 'face 'bold))
                  " "
                  ))
#+END_SRC

Adds as nicely formated clock in all cases, even when not running in EXWM.

#+BEGIN_SRC elisp
  (setq display-time-default-load-average nil)
  (setq display-time-24hr-format t)
  (display-time-mode 1)
#+END_SRC

When editing just one window, left-aligned text is awkwardly too far to the left. The ~perfect-margin~ package fixes this by centering the contents of the window when only one is present.

#+BEGIN_SRC elisp
(use-package perfect-margin
  :custom
  (perfect-margin-visible-width 128)
  :init
  ;; enable perfect-mode
  (perfect-margin-mode t)
  ;; auto-center minibuffer windows
  (setq perfect-margin-ignore-filters nil)
  ;; auto-center special windows
  (setq perfect-margin-ignore-regexps nil))
#+END_SRC

~Rainbow-delimiters~ differentiates layers of parentheses using different colours so that they can be identified at a glance.

#+BEGIN_SRC elisp
  (use-package rainbow-delimiters
    :init
    (setq rainbow-delimiters-mode t))
#+END_SRC

** Dashboard
Configures the all-important emacs dashboard that shows up on startup.
#+BEGIN_SRC elisp
  (use-package dashboard
    :init
    (dashboard-setup-startup-hook)
    (setq dashboard-icon-type 'all-the-icons)
    (setq dashboard-banner-logo-title "Welcome to Kudu Emacs!")
    (setq dashboard-center-content 'middle)
    (setq dashboard-startup-banner
          (if (window-system)
              Kudu-gui-logo
            "~/.emacs.d/Logos/KuduLogo_text.txt"))
    (setq compilation-ask-about-save nil)
    (setq dashboard-show-shortcuts nil)
    (setq dashboard-items '((recents . 5)))
    (setq dashboard-set-navigator nil)
    (setq dashboard-set-init-info t)
    (setq dashboard-set-footer nil)

    (add-hook  'dashboard-mode-hook (lambda () (display-line-numbers-mode -1)))
    (dashboard-open)
    )
#+END_SRC
** Completion
Code completion using corfu.
#+BEGIN_SRC elisp
    (use-package corfu
      :custom
      (setq corfu-auto t)
      :init
      (global-corfu-mode))

    (use-package cape
      ;; Bind dedicated completion commands
      ;; Alternative prefix keys: C-c p, M-p, M-+, ...
      :bind (("C-c p p" . completion-at-point) ;; capf
             ("C-c p t" . complete-tag)        ;; etags
             ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
             ("C-c p h" . cape-history)
             ("C-c p f" . cape-file)
             ("C-c p k" . cape-keyword)
             ("C-c p s" . cape-symbol)
             ("C-c p a" . cape-abbrev)
             ("C-c p l" . cape-line)
             ("C-c p w" . cape-dict)
             ("C-c p \\" . cape-tex)
             ("C-c p _" . cape-tex)
             ("C-c p ^" . cape-tex)
             ("C-c p &" . cape-sgml)
             ("C-c p r" . cape-rfc1345))
      :init
      (add-to-list 'completion-at-point-functions #'cape-dabbrev)
      (add-to-list 'completion-at-point-functions #'cape-file)
      (add-to-list 'completion-at-point-functions #'cape-elisp-block)
      (add-to-list 'completion-at-point-functions #'cape-history)
      (add-to-list 'completion-at-point-functions #'cape-keyword))
  
    (use-package corfu-terminal
      :init
      (unless (display-graphic-p)
        (corfu-terminal-mode +1)))

    (use-package eglot
      :commands (eglot eglot-ensure)
      :hook
      (python-mode . eglot-ensure)
      (LaTeX-mode . eglot-ensure)
      (csharp-mode . omnisharp-mode))

    (use-package vertico
      :init
      (vertico-mode)
      :config
      (setq vertico-count 10)
      (vertico-indexed-mode)
      (vertico-mouse-mode)
      )

    (use-package marginalia
      :hook (vertico-mode . marginalia-mode))

    (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))

  (use-package consult
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)                  ;; Alternative: consult-fd
           ("M-s c" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    :init
    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    :config
    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any)))
#+END_SRC

Tangentially related is flycheck, providing in-buffer syntax checking.
#+BEGIN_SRC elisp
  (use-package flycheck
    :config (global-flycheck-mode +1))
#+END_SRC

** Org-mode
Configures Org-mode to make it more attractive and usable.
#+BEGIN_SRC elisp
    (use-package emacs
      :init
      (setq completion-cycle-threshold 2)
      (setq tab-always-indent 'complete))

    (use-package org
      :config
      (setq org-format-latex-options
            (plist-put org-format-latex-options
                       :scale 1.3
                       ))
      (setq org-format-latex-options
            (plist-put org-format-latex-options
                       :html-scale 3
                       ))
      (setq org-startup-indented t
            org-toggle-pretty-entities t
            org-hide-leading-stars t
            org-hide-emphasis-markers t)
      (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
      )

    (use-package org-superstar
      :hook (org-mode . org-superstar-mode))
    (use-package org-fragtog
      :hook (org-mode . org-fragtog-mode))
    (use-package toc-org
      :hook (org-mode . toc-org-mode))
    (use-package org-appear
      :hook (org-mode . org-appear-mode))
    (use-package yasnippet
      :diminish yas-minor-mode
      :hook (org-mode . yas-minor-mode)
      :config
      (yas-load-directory "~/.emacs.d/snippets/"))
    (use-package yasnippet-snippets)

  (use-package valign
    :hook (org-mode . valign-mode))


    (use-package org-modern
      :hook
      (org-mode . org-modern-mode)
      (org-agenda-finalize . org-modern-agenda)
      :custom
      (org-modern-table-horizontal 2)
      (org-modern-table-vertical 1)
      (org-modern-star nil)
      (org-modern-hide-stars nil)
      (org-modern-checkbox nil)
      )

    (unless (file-directory-p "~/.emacs.d/site-lisp/org-modern-indent")
      (shell-command "git clone https://github.com/jdtsmith/org-modern-indent.git ~/.emacs.d/site-lisp/org-modern-indent/"))
    (use-package org-modern-indent
      :load-path "~/.emacs.d/site-lisp/org-modern-indent"
      :hook (org-mode . org-modern-indent-mode))

 #+END_SRC

** Lisp
Emacs is an amazing environment for writing in various lisp dialects, with wonderful support out-of-the-box. However, there are various different packages designed to improve this experience in general or in slight, specific ways. ~Paredit~ is a transformational package for editing S-expressions in a structural way. ~Sly~ is a fork of the popular ~SLIME~ package for an integrated common lisp REPL among other things. It is superior to ~SLIME~ because it has ASCII-art cats. 
#+BEGIN_SRC elisp
  (use-package paredit
    :hook ((lisp-mode . paredit-mode)
           (emacs-lisp-mode . paredit-mode)
           (scheme-mode . paredit-mode)
           (slime-mode . paredit-mode))
    :config
    (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t))

  (defun override-slime-del-key ()
    (define-key slime-repl-mode-map
                (read-kbd-macro paredit-backward-delete-key) nil))
  (add-hook 'slime-repl-mode-hook 'override-slime-del-key)

  (use-package sly
    :config
    (setq inferior-lisp-program "sbcl"))

  (setq show-paren-delay 0)
  (show-paren-mode)
#+END_SRC

Due to Kudus's deep integration with the GNU Guix system, it is only natural to improve the systems used to interact with guile and scheme specifically. For this the ~guix.el~ and the wonderful ~geiser~ packages are used, where ~guix.el~ is a magit-inspired Emacs frontend and ~geiser~ is a package aiming to improve the scheme experience in emacs.

#+BEGIN_SRC elisp
  (use-package guix)

  (use-package geiser-guile)
#+END_SRC

** Dired
Dired is emacs' built in text-based file manager. It's however pretty rough around its edges, such as it opening each directory in a separate buffer making navigation a hassle. However certain tweaks can make it a formidable tool accessible directly within emacs. Take that nÂ³ and midnight commander!

#+BEGIN_SRC elisp
    (use-package openwith
      :hook (dired-mode . openwith-mode)
      :config
      (setq openwith-associations (list
                                   (list (openwith-make-extension-regexp
                                          '("png" "jpg" "jpeg")) "eog" '(file))
                                   (list (openwith-make-extension-regexp
                                          '("mkv" "mp4" "avi")) "mpv" '(file))
                                   )))
    (setf dired-kill-when-opening-new-dired-buffer t)
    (setq dired-listing-switches "-aBhl  --group-directories-first")
    (defalias 'eaf-open-in-file-manager #'dired)

  (add-hook 'dired-mode-hook 'toggle-truncate-lines)

  (use-package pdf-tools
    :init
    (pdf-loader-install)
    (add-hook  'pdf-view-mode-hook (lambda () (display-line-numbers-mode -1)))
    )

  #+END_SRC
  
** Parens pairing
Most of the time when writing parentheses, brackets, and quotes we want to pair them. This significantly improves comfort since you no longer need to stretch for modifier keys to finish of the pair. And even if you do, ~electric-pair-mode~ will detect it and move the point past as if you had just entered the character.

#+BEGIN_SRC elisp
  (setq electric-pair-pairs '(
                              (?\{ . ?\})
                              (?\( . ?\))
                              (?\[ . ?\])
                              (?\" . ?\")
                              (?\$ . ?\$)
                              ))
  (electric-pair-mode t)
#+END_SRC

** Magit
Magit is wonderful, and one of the killer apps that makes emacs a system than other editors or IDEs. However it is not installed by default, so it is defined here.
#+BEGIN_SRC elisp
  (use-package magit)

  (use-package magit-todos
    :after magit
    :config (magit-todos-mode 1))

  (use-package magit-delta
    :after magit
    :config (magit-delta-mode t))
#+END_SRC

** Functions
The sudo function raises the privilege of the current buffer to root permissions without having to close and open it again through ~TRAMP~.
#+BEGIN_SRC elisp
  (defun sudo ()
    (interactive)
    (let ((position (point)))
      (find-alternate-file (concat "/sudo::"
                                   (buffer-file-name (current-buffer))))
      (goto-char position)))

  (defun kill-magit-buffers ()
    (interactive)
    (mapc (lambda (buffer) 
            (when (eq 'magit-mode (buffer-local-value 'major-mode buffer)) 
              (kill-buffer buffer))) 
          (buffer-list)))
#+END_SRC

** Emacs Application Framework
#+BEGIN_SRC elisp
  (unless (file-directory-p "~/.emacs.d/site-lisp/emacs-application-framework")
    (shell-command "git clone --depth=1 -b master https://github.com/emacs-eaf/emacs-application-framework.git ~/.emacs.d/site-lisp/emacs-application-framework/"))
  (if (get-buffer "*Shell Command Output*") (kill-buffer "*Shell Command Output*"))

  (add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework/")
  (require 'eaf)
  (require 'eaf-browser)
  (require 'eaf-map)

  (use-package eaf
      :load-path "~/.emacs.d/site-lisp/emacs-application-framework.emacs.d/site-lisp/emacs-application-framework"
      :config
      (eaf-browser-enable-adblocker t)
      (browse-url-browser-function 'eaf-open-browser-open-browser)
      (defalias 'browse-web #'eaf-open-browser)
      (setq eaf-browser-default-search-engine "duckduckgo")
      (setq eaf-browse-blank-page-url "https://duckduckgo.com")
      (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
      (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
      (eaf-bind-key take_photo "p" eaf-camera-keybinding)
      (eaf-bind-key nil "M-q" eaf-browser-keybinding))
#+END_SRC

