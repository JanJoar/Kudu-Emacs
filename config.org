

#    Kudu --- A fully functioning Gnu Emacs system
#    Copyright (C) 2023  Joar von Arndt
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.

#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.

#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <https://www.gnu.org/licenses/>.

#+title: Kudu
#+author: Joar von Arndt
#+STARTUP: overview
* What is Kudu?
[[https://github.com/JanJoar/Kudu-Emacs/blob/main/Logos/KuduLogo_red.svg]]

The complexity and extensibility of GNU Emacs, paired with its lack of integration with contemporary technical standards, has driven the development of Emacs distributions that contain packages and functionality not included by the GNU project. Kudu is a project meant to expand the scope of such distributions to every user-facing part of the operating system using dialects of the lisp programming language. This allows the user to easily and seamlessly "live in Emacs", using tools integrated directly into the program, such as the Emacs X Window Manager (EXWM), guix.el, and the Emacs Application Framework (EAF). Earlier distributions have focused on integrating Emacs within an otherwise alien system, like DOOM's and Spacemacs' focus on keybinds derived from the Vi editor, to maximize the number of workflows that the distribution could be incorporated into. Kudu does not take this approach, but rather empowers the user to construct their own system within a completely configurable system. All tools are written in lisp, the simple syntax of which allows for a seamless experience and self-sufficient system capable of performing all the daily tasks of modern life. It is hoped that this declarative and atomic system offered by GNU Guix will allow more secure and maintainable infrastructure.


The origin for the name is the kudu, an antelope similar to that of the Gnu, the namesake of the GNU Project. Kudu is not part of the GNU Project, and its developers are not members of GNU or the FSF. However we share a positive opinion of free software and therefore want to contribute to its mainstream adoption. 
* Configuration

** Use-package

Probably one of the most useful packages, even if not very prominent when using emacs, is ~use-package~. It allows you to declaratively write your configuration and have the included emacs package manager download them for you, and also have configurations for packages only run when packages are loaded, similarly to ~(with-eval-after-load ...)~. The variables set here simply enable this behaviour. If the version of Emacs is older than Emacs 29, ~use-package~ won't be available by default. It is therefore installed here as well.

The ~diminish~ package hides certain minor modes from being shown in the mode-line and is not installed by default. For this reason its used to check if Kudu has been run before, and therefore if it needs to update its package repos. Feel free to perform this check on any other package, or remove it entirely, but beware that ~(package-refresh-contents)~ must be run before the other ~use-package~ declarations for ~package.el~ to install all the other packages needed.

#+begin_src emacs-lisp tangle: yes
(setq use-package-always-defer t
        use-package-always-ensure t
        use-package-verbose t)

  (unless (package-installed-p 'diminish)
      (package-refresh-contents)
      (package-install 'use-package)
      (package-install 'diminish))
#+END_SRC

** Auto-compile

Compiles elisp files to improve the speed and responsiveness of Emacs at the cost of first-time startup time. The settings in ~init.el~ makes sure that updated elisp files take priority over older, compiled files.

#+begin_src emacs-lisp tangle: yes
  (use-package auto-compile 
	:ensure t
	:init
	(auto-compile-on-load-mode 1)
	(auto-compile-on-save-mode 1))
  
    (setq native-comp-async-report-warnings-errors nil)
#+end_src

** Backups

Emacs usually stores backups in the same directory as the files themselves, cluttering up your nice and tidy system. This moves them to a dedicated directory within ~.emacs.d~.

#+begin_src emacs-lisp tangle: yes
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

** EXWM
The Emacs X Window Manager allows you to use your entire desktop within emacs. Other windows are managed like traditional emacs buffers, and different workspace are implemented using separate emacs frames. This is arguably the largest change to using traditional window managers and desktop environments, and it transforms emacs from simply a program that can do everything to /the/ way to interact with one's computer.

However, Emacs can still be used without constituting the entire system. Therefore EXWM should only be loaded if no other window manager is running. That way startup time isn't wasted whenever the user wants to run Emacs in the terminal, on a computer using a desktop environment, or another window manager.

#+begin_src emacs-lisp tangle: yes
  (use-package exwm
    :init

    ;; EXWM related functions

    (defun xrandr-find-monitor-names ()
      "Returns a list of connected monitors"
      (let ((xrandr-contents nil) (monitor-names nil))
        (shell-command "xrandr" "*xrandr-output*")
        (switch-to-buffer "*xrandr-output*")
        (setq xrandr-contents (buffer-string))
        (kill-buffer "*xrandr-output*")
        (setq xrandr-contents (replace-regexp-in-string "\\(.* connected\\).*\n\\|.*\n" "\\1" xrandr-contents))
        ;; Find the string only of the monitors that are connected according to xrandr and remove all other text.
        (remove "" (split-string xrandr-contents " connected"))))

    (defun exwm-monitors-format ()
      "Formats the list from xrandr-find-monitor-names to apply EXWM workspaces"
      (let ((monitors (xrandr-find-monitor-names)) (counter 0) (return-value nil))
        (while monitors
          (push counter return-value)
          (push (car monitors) return-value)
          (setq counter (+ counter 1))
          (setq monitors (cdr monitors)))
        (nreverse return-value)))

    (setq switch-to-buffer-obey-display-actions t)
    (defvar exwm-is-running nil)
    (shell-command "wmctrl -m ; echo $status" "*window-manager*" "*window-manager-error*")

    (when (and
           (get-buffer "*window-manager-error*") ;; The shell command has to both encounter an error and a running in an X environment.
           (eq window-system 'x))
      (setq exwm-is-running t)


      (setq battery-mode-line-format "⟨%b%p%%⟩ ")
      (unless (equal "Power N/A, battery unknown (N/A% load, remaining time N/A)" (battery))
        (display-battery-mode 1))
      (setq display-time-day-and-date t)

      (display-time-mode 1)

      ;; Changes the name of EXWM-buffers to the corresponding window-name rather than *EXWM*<N>.
      (add-hook 'exwm-update-class-hook
                (lambda ()
                  (exwm-workspace-rename-buffer exwm-class-name)))

      ;; Configure monitors
      (require 'exwm-randr)
      (setq exwm-randr-workspace-monitor-plist (exwm-monitors-format))
      (setq exwm-workspace-number (length (xrandr-find-monitor-names)))
      (shell-command "bash ~/.screenlayout/desktop.sh")
      (setq exwm-workspace-number (/ (length (exwm-monitors-format)) 2))      
      (exwm-randr-enable)

      ;; These  keys will always be sent to EXWM rather than to the X window.
      (setq exwm-input-prefix-keys
            '(?\C-x
              ?\C-g
              ?\M-x
              ?\M-z))

      ;; Sends the key after C-q directly to the X window.
      ;; (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

      (setq exwm-input-global-keys
            `(
              ([?\s-r] . exwm-reset)
              ([s-left] . windmove-left)
              ([s-right] . windmove-right)
              ([s-up] . windmove-up)
              ([s-down] . windmove-down)
              ([?\s-w] . exwm-workspace-switch)
              ([?\C-q] . exwm-input-send-next-key)
              ([?\s-a] . (lambda (command)
                           (interactive (list (read-shell-command " λ ")))
                           (start-process-shell-command command nil command)))
              ([?\s-w] . exwm-workspace-switch)
              ([?\s-u] . (lambda ()
                           (interactive)
                           (shell-command "brightnessctl --quiet --min-value set +10")))
              ([?\s-d] . (lambda ()
                           (interactive)
                           (shell-command "brightnessctl --quiet --min-value set 10-")))
              ))
      ;; Actually starts EXWM
      (exwm-enable))

    (when (get-buffer "*window-manager*")
      (kill-buffer "*window-manager*"))
    (when (get-buffer "*window-manager-error*")
      (kill-buffer "*window-manager-error*")))
#+end_src

** General visual elements
Visible bell changes the otherwise quite jarring bell sound into a visual flash on it top and bottom of the emacs frame. ~prettify-symbols-mode~ allows certain major modes to change the appearance of strings, the classic example being the Greek letter lambda in lisp-modes for lambda calculus. ~pixel-scroll-precision-mode~ allows you to scroll past things like images without buffers jumping around all the time.
 
#+begin_src emacs-lisp :tangle yes
  (setq visible-bell t
        global-prettify-symbols-mode 1
        pixel-scroll-precision-mode t)

  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'prog-mode-hook '(lambda () (toggle-truncate-lines 1)))
#+end_src

Solaire-mode makes it easy to distinguish between warnings, popups and messages by tinting the background of those buffers slightly darker, as long as the current theme supports it.

#+begin_src emacs-lisp :tangle yes
  (use-package solaire-mode
    :init
    (solaire-global-mode))
  
  (setq pixel-scroll-precision-mode t)
#+end_src

Formats tabs to Linux-kernel standards and keeps them so using the ~aggressive-indent~ package.

#+begin_src emacs-lisp :tangle yes
  (setq-default tab-width 8)
  (setq-default standard-indent 8)
  (setq-default indent-tabs-mode nil)

  (use-package aggressive-indent
    :diminish aggressive-indent-mode
    :init (global-aggressive-indent-mode))
#+end_src

Enable mouse use when running Emacs in a terminal emulator.

#+begin_src emacs-lisp :tangle yes
  (xterm-mouse-mode)
#+end_src

Without this setting emacs sometimes asks for confirmation via a "Yes or no" prompt, and sometimes "y or n". This is generally difficult to predict, and so this setting forces the message to always send "y or n" forms, like most programs run in a terminal.

#+begin_src emacs-lisp :tangle yes
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

The default Emacs mode-line is a bit busy and certain elements of it are difficult to intuitively understand. This simplifies it considerably to make it more readable and also adds a header line.

#+begin_src emacs-lisp :tangle yes

  (defun mode-line-padding ()
    "Sets the spacing between left and right aligned things in the mode line."
    (let ((r-length (length (format-mode-line mode-line-end-spaces))))
      (propertize " "
                  'display `(space :align-to (- right ,r-length)))))

  (setq-default mode-line-format
                '(
                  "%e"
                  (:eval (unless (string-match-p "\\*.*\\*" (buffer-name))
                           (let* ((read-only (and buffer-read-only (buffer-file-name)))
                                  (modified (buffer-modified-p)))
                             (propertize
                              (if buffer-read-only "|    |"
                                (if modified "| ☦ |"
                                  "|    |"))))))
                  "  "
                  mode-name
                  " "
                  mode-line-buffer-identification
                  (vc-mode vc-mode)
                  (:eval (mode-line-padding))
                  (:eval (setq mode-line-end-spaces mode-line-misc-info))))
#+end_src

Adds as nicely formatted clock in all cases, even when not running in EXWM.

#+begin_src emacs-lisp :tangle yes
  (setq display-time-default-load-average nil)
  (setq display-time-24hr-format t)
  (display-time-mode 1)
#+end_src

When prose for publication the traditional centered appearance of WYSISWYG is quite comfortable. The ~olivetti~ package does this by centering the contents of the windows where this type of content is displayed.

#+begin_src emacs-lisp :tangle yes
  (use-package olivetti
      :hook
      (org-mode . olivetti-mode)
      (markdown-mode . olivetti-mode)
      (eww-mode . olivetti-mode)
      :init
      (setq-default olivetti-body-width 108))
#+end_src

~rainbow-delimiters~ differentiates layers of parentheses using different colours so that they can be identified at a glance.

#+begin_src emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src

~smartparens~ is intended to help in a similar way by highlighting the current sexp.

#+begin_src emacs-lisp :tangle yes
  (use-package smartparens
    :hook
    (prog-mode . smartparens-mode)
    (text-mode . smartparens-mode)
    :init
    (require 'smartparens-config))
#+end_src

Adds little icons for completion frameworks.

#+begin_src emacs-lisp :tangle yes
  (use-package svg-lib)
  (use-package kind-icon
    :after corfu
    :custom (kind-icon-default-face 'corfu-default)
    :init (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)
    (unless (display-graphic-p)
      (setq kind-icon-use-icons nil)))
#+end_src

Emacs is a wonderful alternative to a terminal, encompassing [[https://www.masteringemacs.org/article/running-shells-in-emacs-overview][many of the features]] seen in modern terminals. For a cleaner look, this hides the mode-line in windows used to interact with shells.

#+begin_src emacs-lisp :tangle yes
  (use-package hide-mode-line
    :hook
    (eat-mode . hide-mode-line-mode)
    (term-mode . hide-mode-line-mode)
    (eshell-mode . hide-mode-line-mode)
    (dashboard-mode . hide-mode-line-mode)
    (pdf-view-mode . hide-mode-line-mode))
#+end_src

~Rainbow-mode~ makes colour codes into the colours that they represent.

#+begin_src elisp
  (use-package rainbow-mode
    :config
    (setq rainbow-html-colors 'auto)
    (setq rainbow-latex-colors 'auto)
    (setq rainbow-ansi-colors 'auto)
    (setq rainbow-r-colors 'auto)
    :hook (prog-mode . rainbow-mode))
#+end_src

** Dashboard

Configures the all-important emacs dashboard that shows up on startup.

#+begin_src emacs-lisp :tangle yes
  (use-package dashboard
    :hook
    (dashboard-mode . (lambda () (solaire-mode -1)))
    :init
    (dashboard-setup-startup-hook)
    (setq dashboard-icon-type 'all-the-icons)
    (setq dashboard-banner-logo-title "Welcome to Kudu Emacs!")
    (setq dashboard-center-content 'middle)
    (setq dashboard-startup-banner
          (if (window-system)
              Kudu-gui-logo
            "~/.emacs.d/Logos/KuduLogo_text.txt"))
    (setq compilation-ask-about-save nil)
    (setq dashboard-show-shortcuts nil)
    (setq dashboard-items '((recents . 5)))
    (setq dashboard-set-navigator nil)
    (setq dashboard-set-init-info t)
    (setq dashboard-set-footer nil)
    (dashboard-setup-startup-hook)

    (add-hook  'dashboard-mode-hook (lambda ()
                                      (display-line-numbers-mode -1)
                                      (setq cursor-type nil))))
#+end_src

** Completion

*** Corfu

In-buffer code completion using ~corfu~.
By default ~corfu~ only works in a GUI environment, but the ~corfu-terminal~ package allows for use when run using the ~-nw~ flag.

#+begin_src emacs-lisp :tangle yes
  (use-package corfu
    :custom
    (setq corfu-auto t)
    :init
    (global-corfu-mode)
    (corfu-history-mode)
    (setq corfu-popupinfo-delay 0.5)
    (corfu-popupinfo-mode +1))

  (use-package corfu-terminal
      :init
      (unless (display-graphic-p)
        (corfu-terminal-mode +1)))
  #+end_src

*** Cape

  ~corfu~ does not provide candidates for completion, but this is provided by ~cape~, or the Completion At Point Extensions package.
  
  #+begin_src emacs-lisp :tangle yes
    (use-package cape
      ;; Bind dedicated completion commands
      ;; Alternative prefix keys: C-c p, M-p, M-+, ...
      :bind (("C-c p p" . completion-at-point) ;; capf
             ("C-c p t" . complete-tag)        ;; etags
             ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
             ("C-c p h" . cape-history)
             ("C-c p f" . cape-file)
             ("C-c p k" . cape-keyword)
             ("C-c p a" . cape-abbrev)
             ("C-c p l" . cape-line)
             ("C-c p w" . cape-dict)
             ("C-c p \\" . cape-tex)
             ("C-c p _" . cape-tex)
             ("C-c p ^" . cape-tex)
             ("C-c p &" . cape-sgml)
             ("C-c p r" . cape-rfc1345))
      :init
      (setq cape-dict-file (list "/home/jovo/Documents/Papers/english-dict" "/home/jovo/Documents/Papers/swedish-dict"))
      (add-to-list 'completion-at-point-functions #'cape-dict)
      (add-to-list 'completion-at-point-functions #'cape-abbrev)
      (add-to-list 'completion-at-point-functions #'cape-file)
      (add-to-list 'completion-at-point-functions #'cape-dabbrev)
      (add-to-list 'completion-at-point-functions #'cape-abbrev)
      (add-to-list 'completion-at-point-functions #'cape-history)
      (add-to-list 'completion-at-point-functions #'cape-elisp-block)
      (add-to-list 'completion-at-point-functions #'cape-keyword)
      (add-to-list 'completion-at-point-functions #'cape-elisp-symbol)
      (add-to-list 'completion-at-point-functions #'cape-emoji)
      (add-to-list 'completion-at-point-functions #'cape-tex))
 #+end_src

*** Minibuffer Completion

 Uses ~vertico~ to show minibuffer completion, and ~marginalia~ and ~orderless~ to format it.
 
 #+begin_src emacs-lisp :tangle yes
   (use-package vertico
     :init
     (vertico-mode)
     :config
     (setq vertico-count 10)
     (vertico-indexed-mode)
     (vertico-mouse-mode))

   (use-package marginalia
     :config
     (setq marginalia-separator " | ")
     (setq marginalia-align 'center)
     :init (marginalia-mode 1))

   (use-package orderless
   :custom
   (completion-styles '(orderless basic prescient))
   (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

*** Prescient

Shows those completion results that are hopefully most useful, both in the minibuffer and the main buffer.

#+begin_src emacs-lisp :tangle yes
  (use-package prescient
    :init
    (setq prescient-persist-mode t)
    (setq prescient-history-length 5)
    (setq prescient-sort-full-matches-first t))

  (use-package corfu-prescient
    :init (corfu-prescient-mode +1))
  
  (use-package vertico-prescient
    :init (vertico-prescient-mode +1))
#+end_src

*** Consult

~consult~ provides various functions that integrates with the completion API.

#+begin_src emacs-lisp :tangle yes
  (use-package consult
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)                  ;; Alternative: consult-fd
           ("M-s c" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    :init
    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    :config
    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any)))
#+end_src

*** Flycheck

Tangentially related is flycheck, providing in-buffer syntax checking.

#+begin_src emacs-lisp :tangle yes
  (use-package flycheck
    :hook (prog-mode . flycheck-mode))
#+end_src

** Org-mode

Configures Org-mode to make it more attractive and usable.

#+begin_src emacs-lisp :tangle yes
  (setq completion-cycle-threshold 2)
  (setq tab-always-indent 'complete)
  (setq ispell-program-name "hunspell")
  (setq ispell-local-dictionary-alist
      '(("english" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_GB") nil utf-8)
        ("svenska" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "sv_SE") nil utf-8)))

  (use-package auto-dictionary
    :hook
    (flyspell-mode . auto-dictionary-mode))

  (use-package org
    :defer 18
    :config
    (setq org-format-latex-options
          (plist-put org-format-latex-options
                     :scale 1.3
                     ))
    (setq org-format-latex-options
          (plist-put org-format-latex-options
                     :html-scale 3
                     ))
    (setq org-startup-indented t
          org-toggle-pretty-entities t
          org-hide-leading-stars t
          org-hide-emphasis-markers t)
    (add-hook 'text-mode-hook 'turn-on-visual-line-mode))

  (use-package org-superstar
    :hook (org-mode . org-superstar-mode))
  (use-package org-fragtog
    :hook (org-mode . org-fragtog-mode))
  (use-package toc-org
    :hook (org-mode . toc-org-mode))
  (use-package org-appear
    :hook (org-mode . org-appear-mode))
  (use-package yasnippet
    :diminish yas-minor-mode
    :hook (org-mode . yas-minor-mode)
    :config
    (yas-load-directory "~/.emacs.d/snippets/"))
  (use-package yasnippet-snippets)

  (if (display-graphic-p)
      (use-package valign
        :hook (org-mode . valign-mode)))

  (use-package org-modern
    :hook
    (org-mode . org-modern-mode)
    (org-agenda-finalize . org-modern-agenda)
    :custom
    (setq org-modern-table nil)
    (org-modern-star nil)
    (org-modern-hide-stars nil)
    (org-modern--table nil))

  (setq org-export-with-email t)
  (setq org-export-with-smart-quotes t)
  (setq org-export-with-section-numbers nil)
  (setq org-export-with-statistics-cookies nil)

  (unless (file-directory-p "~/.emacs.d/site-lisp/org-modern-indent")
    (async-shell-command "git clone https://github.com/jdtsmith/org-modern-indent.git ~/.emacs.d/site-lisp/org-modern-indent/"))

  (use-package org-modern-indent
    :load-path "~/.emacs.d/site-lisp/org-modern-indent"
    :hook (org-mode . org-modern-indent-mode))
 #+end_src

*** Org-roam

#+begin_src emacs-lisp :tangle yes
  (use-package org-roam
    :config
    (setq org-roam-directory "~/Documents/Notes/roam/")
    (org-roam-db-autosync-mode)
    (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag))))

  (use-package org-roam-ui
    :after org-roam
    :config
    (setq org-roam-ui-sync-theme t
      org-roam-ui-follow t
      org-roam-ui-update-on-save t
      org-roam-ui-open-on-start t))
#+end_src

** Lisp

Emacs is an amazing environment for writing in various lisp dialects, with wonderful support out-of-the-box. However, there are various different packages designed to improve this experience in general or in slight, specific ways. ~Sly~ is a fork of the popular ~SLIME~ package for an integrated common lisp REPL among other things. It is superior to ~SLIME~ because it has ASCII-art cats.

#+begin_src emacs-lisp :tangle yes
  (use-package sly
    :config
    (setq inferior-lisp-program "sbcl"))

  (setq show-paren-delay 0)
  (show-paren-mode)
#+end_src

*** Scheme

Due to Kudu's deep integration with the GNU Guix system, it is only natural to improve the systems used to interact with guile and scheme specifically. For this the ~guix.el~ and the wonderful ~geiser~ packages are used, where ~guix.el~ is a magit-inspired Emacs frontend and ~geiser~ is a package aiming to improve the scheme experience in emacs, with ~geiser-x~ providing special support for working the relevant flavour of scheme.

#+begin_src emacs-lisp :tangle yes
  (use-package guix)

  (use-package geiser-guile)
  (use-package geiser-chez)
  (use-package geiser-mit)
  (use-package geiser-chicken)
  (use-package geiser-racket)
  (use-package geiser-chibi)
  (use-package geiser-kawa)
  (use-package geiser-gambit)
  (use-package geiser-stklos)
  (use-package geiser-gauche)
#+end_src

*** Parens pairing

Most of the time when writing parentheses, brackets, and quotes we want to pair them. This significantly improves comfort since you no longer need to stretch for modifier keys to finish of the pair. And even if you do, ~electric-pair-mode~ will detect it and move the point past as if you had just entered the character. This is of course not just useful for lisp, but in any context when writing pairs of brackets or parentheses.

#+begin_src emacs-lisp :tangle yes
  (setq electric-pair-pairs '((?\{ . ?\})
                              (?\( . ?\))
                              (?\[ . ?\])
                              (?\" . ?\")))
  (electric-pair-mode t)
#+end_src

** File management

Dired is emacs' built in text-based file manager. It's however pretty rough around its edges, such as it opening each directory in a separate buffer making navigation a hassle. However certain tweaks can make it a formidable tool accessible directly within emacs. Take that n³ and midnight commander!

#+begin_src emacs-lisp :tangle yes
  (defun dired-open-with-find-file (orig-fun &optional other-window)
    "Run dired-open-with if the file is a PDF, image, or video."
    (let ((file (dired-get-filename)))
      (if (and file
               (or (string-match "\\.pdf\\'" file)
                   (string-match "\\.png\\'" file)
                   (string-match "\\.jpg\\'" file)
                   (string-match "\\.jpeg\\'" file)
                   (string-match "\\.mkv\\'" file)
                   (string-match "\\.mp4\\'" file)
                   (string-match "\\.avi\\'" file)))
          (dired-open-with)
        (funcall orig-fun))))  ;; Call the original function for other file types.

  (use-package dired-open-with
    :config
    (advice-add 'dired-find-file :around 'dired-open-with-find-file))

  (setf dired-kill-when-opening-new-dired-buffer t)
  (setq dired-listing-switches "-BhlD  --group-directories-first")
  (defalias 'eaf-open-in-file-manager #'dired)

  (add-hook 'dired-mode-hook 'toggle-truncate-lines)
  (add-hook 'dired-mode-hook 'display-line-numbers-mode)

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode)
    :config (setq all-the-icons-dired-monochrome nil))

  (use-package lin
    :config
    (lin-global-mode))
#+end_src

** PDF-tools

The default "docview" mode of viewing pdfs is quite bad, and is improved immensely by the pdf-tools package. For some this may not be enough, and it is possible to replace it with an external pdf viewer (like evince or zathura) using the above ~openwith~ package. 

#+begin_src emacs-lisp :tangle yes
  (use-package pdf-tools
    :init
    (pdf-loader-install)
    (add-hook  'pdf-view-mode-hook (lambda () (display-line-numbers-mode -1))))
  #+end_src
  
** Version Control

Magit is wonderful, and one of the killer apps that makes emacs a system than other editors or IDEs. However it is not installed by default, so it is defined here.

#+begin_src emacs-lisp :tangle yes
  (use-package magit)

  (use-package magit-todos
    :after magit
    :config (magit-todos-mode 1))

  (use-package magit-delta
    :after magit
    :config (magit-delta-mode t))

  (use-package forge
    :after magit
    :hook (magit-status-mode-hook . forge-pull))
#+end_src

For displaying who is responsible (and when) for changes to files, the ~blamer~ package is used, displaying a small piece of text to the left of the buffer content.

#+begin_src emacs-lisp :tangle yes
  (use-package blamer
    :bind (("C-," . blamer-show-commit-info))
    :defer 10
    :custom
    (setq blamer-idle-time 20.0)
    (blamer-min-offset 70)
    :config
    (add-hook 'prog-mode-hook 'blamer-mode)
    (setq blamer-author-formatter " ⏵ %s ")
    (setq blamer-datetime-formatter "⟨%s⟩")
    (setq blamer-commit-formatter " ☨ %s"))
#+end_src

** Tooling

Emacs has a wonderful undo-system, but it can be hard to get an idea of how it works intuitively. ~undo-tree~ helps with this by creating a wonderful visualization for your branching undo, well, tree.

#+begin_src emacs-lisp :tangle yes
  (use-package undo-tree
    :init
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-auto-save-history t)
    (unless (file-exists-p "~/.emacs.d/undo-tree") 
      (make-directory "~/.emacs.d/undo-tree"))
    (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo-tree")))
    (global-undo-tree-mode +1))
#+end_src

  Uses the ~ace-window~ package for switching windows instead of the default ~other-window~.
  
#+begin_src emacs-lisp :tangle yes
  (use-package ace-window
    :init
    (global-set-key (kbd "C-x o") 'ace-window)
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (setq aw-ignore-current t))

  (use-package avy
    :init
    (bind-key "C-<tab>" 'avy-goto-char-timer))
#+end_src


Emacs is better than any terminal emulator, and being able to run emacs lisp code in a terminal through ~eshell~ is increadibly powerful. But ~eshell~ has trouble running full-screen terminal programs, and so the ~eat~ (Emulate A Terminal) package is used for those programs that need it.

#+begin_src emacs-lisp :tangle yes
  (use-package eat
    :hook
    (eshell-load-hook . eat-eshell-mode)
    :config
    (setq eat-kill-buffer-on-exit t)
    (keymap-set eat-mode-map "M-w" 'kill-ring-save))

  (use-package fish-completion
    :init (when (executable-find "fish")
            (add-hook 'eshell-load-hook (fish-completion-mode)))
    :config
    (use-package bash-completion))

  (use-package eshell
    :config
    ;; Create a new lambda-themed prompt.
    (setq eshell-prompt-function
      (lambda ()
        (concat (abbreviate-file-name (eshell/pwd)) " λ ")))
    (setq eshell-prompt-regexp "^[^λ]* λ")

    (setq eshell-scroll-to-bottom-on-input 'all)
    (setq-local tab-always-indent 'complete)
    (setq eshell-history-size 10000)
    (setq eshell-save-history-on-exit t)
    (setq eshell-hist-ignoredups t)

    (defalias 'eshell/clear 'eshell/clear-scrollback))
#+end_src

One of the things that make Emacs so extensible is the easy access to documentation of functions and variables through the ~C-h~ series of keybinds. The ~helpful~ package continues this by improving the default help buffers with more information and better formatting. ~Eldoc-box~ instead shows Eldoc documentation in a pretty and modern-looking format inside of your buffer, rather than down at the minibuffer.

#+begin_src emacs-lisp :tangle yes
    (use-package helpful
      :bind (("C-c C-d" . helpful-at-point)
             ("C-h v" . helpful-variable)
             ("C-h f" . helpful-callable)
             ("C-h x" . helpful-command)
             ("C-h k" . helpful-key)))

    (use-package eldoc-box
      :init

      (defun kudu-eldoc-box ()
          "Runs eldoc-box-hover-mode or hover-at-point-mode depending on perfect-margin-mode"
        (if perfect-margin-mode
            (setq eldoc-box-hover-mode t)
          (setq eldoc-box-hover-at-point-mode t)))

      :hook (prog-mode . kudu-eldoc-box)
      :config
      (add-hook 'perfect-margin-hook 'kudu-eldoc-box)
      (setq eldoc-box-only-multi-line t))
#+end_src

Automatically compresses and decompresses files.

#+begin_src emacs-lisp :tangle yes
(auto-compression-mode)
#+end_src

** Functions

The sudo function raises the privilege of the current buffer to root permissions without having to close and open it again through ~TRAMP~.

#+begin_src emacs-lisp :tangle yes
  (defun sudo ()
    "Opens the current buffer at point with root privelages using TRAMP."
    (interactive)
    (let ((position (point)))
      (find-alternate-file (concat "/sudo::"
                                   (buffer-file-name (current-buffer))))
      (goto-char position)))
#+end_src

Magit can sometimes create a lot of buffers for different processes that are annoying to close one by one, this function closes all buffers whose name contains "magit".

#+begin_src emacs-lisp :tangle yes

  (defun kill-magit-buffers ()
    "Kills all buffers whose name begins with magit."
    (interactive)
    (mapc (lambda (buffer) 
            (if (buffer-match-p ".*magit.*" buffer) 
              (kill-buffer buffer))) 
          (buffer-list)))
#+end_src

Emacs does not have a nice easy to use elisp  function for calculating the factorial of a value, this adds it. This works out particularly nicely since the standard notation for the factorial of a value uses prefix notation.

#+begin_src emacs-lisp :tangle yes

  (defun ! (n)
    "An emacs function to calculate the factorial of n using the calc library."
    (let ((output (string-to-number (calc-eval (format "%s!" n)))))
      (kill-buffer "*Calculator*")
      output))
#+end_src

Function for calculation the number of possible permutations and combinations respectively.

#+begin_src emacs-lisp :tangle yes

  (defun nPr (n k)
    "A function for calculating the number of permutations in combinatorics."
    (/
     (! n)
     (! (- n k))))

  (defun nCr (n k)
    "A function for calculating the number of combinations in combinatorics."
    (/
     (! n)
     (* (! k) (! (- n k)))))
#+end_src

Allows you to save a flyspell word at point to your personal dictionary.

#+begin_src emacs-lisp :tangle yes
  (defun flyspell-save-word ()
    (interactive)
    (let ((current-location (point))
          (word (flyspell-get-word)))
      (when (consp word)    
        (flyspell-do-correct 'save nil (car word) current-location (cadr word) (caddr word) current-location))))

  (add-hook 'org-mode-hook (lambda ()
                             (keymap-set org-mode-map "C-c C-v"
                                         'flyspell-save-word)))
#+end_src


#+begin_src emacs-lisp :tangle yes
  (defun load-emacs-secret-file ()
    "Load the .emacs.d/secrets/ file"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/secrets/secret.org")))
#+end_src

** Mail

Emacs provides many different mail utilities, but one of the most popular is ~mu4e~ (Mail Utilities for Emacs). Using this requires an IMAP server to something similar to store mail the in ~HOME/mail/~ directory and a local SMTP server to send the mail. 

#+begin_src emacs-lisp :tangle yes

  (use-package mu4e
    :defer 10
    :ensure nil
    :config

    (defalias 'email #'mu4e "Defines an email command to run mu4e.")

    (setq mu4e-change-filenames-when-moving t ; avoid sync conflicts
          mu4e-update-interval (* 10 60) ; check mail 10 minutes
          mu4e-compose-format-flowed t ; re-flow mail so it's not hard wrapped
          mu4e-get-mail-command "mbsync -a"
          mu4e-maildir "/mail")

    (setq mail-user-agent 'mu4e-user-agent)
    (setq message-kill-buffer-on-exit t)

    (setq mu4e-drafts-folder "/mail/Drafts"
          mu4e-sent-folder   "/mail/Sent"
          mu4e-refile-folder "/mail/All Mail"
          mu4e-trash-folder  "/mail/Trash")

    (setq mu4e-maildir-shortcuts
          '(("/mail/inbox"     . ?i)
            ("/mail/Sent"      . ?s)
            ("/mail/Trash"     . ?t)
            ("/mail/Drafts"    . ?d)
            ("/mail/All Mail"  . ?a)))

    (setq message-send-mail-function 'smtpmail-send-it
          auth-sources '("~/.authinfo")
          smtpmail-smtp-server "127.0.0.1"
          smtpmail-smtp-service 1025
          smtpmail-stream-type  'ssl))
#+end_src

Allows notify-send to inform you of new emails when not using Emacs, and adds a nice mode-line decoration to remind you.

#+begin_src emacs-lisp :tangle yes

    (use-package mu4e-alert
      :after mu4e
      (mu4e-alert-set-default-style 'libnotify)
      (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
      (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))
#+end_src

Allows you to write nicely formatted HTML emails using org-mode to fit in with the rest of society.

#+begin_src emacs-lisp :tangle yes

  (use-package org-msg
    :after mu4e
    :config
    (setq mail-user-agent 'mu4e-user-agent)
    (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
          org-msg-startup "hidestars indent inlineimages"
          org-msg-default-alternatives '((new		. (text html))
                                         (reply-to-html	. (text html))
                                         (reply-to-text	. (text)))
          org-msg-convert-citation t)
    (org-msg-mode))
#+end_src
